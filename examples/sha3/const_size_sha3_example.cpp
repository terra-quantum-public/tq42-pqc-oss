// SHA3 is a hash-function. Input data - message of any size.
// Hash of fixed size is saved into hash array.
// Look shake_sha3_example.cpp to use arbitary size of hash.
#include <cstring>
#include <iostream>
#include <memory>

#include <pqc/sha3.h>

int main(void)
{
    const int sha_len =
        PQC_SHA3_512; // fixed size of hash. It can be one of PQC_SHA3_224, PQC_SHA3_256, PQC_SHA3_384, PQC_SHA3_512
                      // Please note that expected value of SHA3 hash is valid only for PQC_SHA3_512.
    const int message_len = 200;

    // Message is a data to get hash from.
    uint8_t message[message_len] = {
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
        0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3};

    uint8_t expected[] = {0xE7, 0x6D, 0xFA, 0xD2, 0x20, 0x84, 0xA8, 0xB1, 0x46, 0x7F, 0xCF, 0x2F,
                          0xFA, 0x58, 0x36, 0x1B, // Expected 512-bit (PQC_SHA3_512) SHA3 hash for message above
                          0xEC, 0x76, 0x28, 0xED, 0xF5, 0xF3, 0xFD, 0xC0, 0xE4, 0x80, 0x5D, 0xC4,
                          0x8C, 0xAE, 0xEC, 0xA8, 0x1B, 0x7C, 0x13, 0xC3, 0x0A, 0xDF, 0x52, 0xA3,
                          0x65, 0x95, 0x84, 0x73, 0x9A, 0x2D, 0xF4, 0x6B, 0xE5, 0x89, 0xC5, 0x1C,
                          0xA1, 0xA4, 0xA8, 0x41, 0x6D, 0xF6, 0x54, 0x5A, 0x1C, 0xE8, 0xBA, 0x00};


    CIPHER_HANDLE sha3 = PQC_context_init_hash(PQC_CIPHER_SHA3, sha_len);


    // Add message content to the hash function
    size_t PQC_hash_update_return = PQC_hash_update(sha3, message, message_len);
    if (PQC_hash_update_return != PQC_OK)
        std::cout << "\nERROR!!! Returned value must be PQC_OK if operation was done successfully";

    // check hash size
    size_t hash_size = PQC_hash_size(sha3);
    if (hash_size != sha_len / 8)
        std::cout << "\nERROR!!! Returned value must be equal to hash size of this mode!" << std::endl;

    // create memory space for hash result
    std::shared_ptr<uint8_t[]> hash(new uint8_t[hash_size]);

    size_t pqc_hash_retrieve_return = PQC_hash_retrieve(
        sha3, hash.get(), hash_size
    ); // PQC_hash_retrieve gets hash from message. pqc_hash_retrieve_return should be equal to PQC_OK
    if (pqc_hash_retrieve_return != PQC_OK)
        std::cout << "\nERROR!!! Returned value must be PQC_OK if operation was done successfully";

    // close context
    size_t pqClose = PQC_context_close(sha3);
    if (pqClose != PQC_OK)
        std::cout << "\nERROR!!! Returned value must be PQC_OK if operation was done successfully" << std::endl;


    // Verification. Hash should be similar with constant digest message for this initial message
    if (memcmp(hash.get(), expected, sha_len / 8) == 0)
    {
        std::cout << "Verification successfull" << std::endl;
    }
    else
    {
        std::cout << "Verification failed" << std::endl;
    }

    return 0;
}
